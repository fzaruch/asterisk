Subject: Add rtstatic=yes option to sip.conf for RT/realtime without host=dynamic
From: Walter Doekes <wjdoekes@osso.nl>
Forwarded: no
Last-Update: 2017-03-17

This patch does two things:

 * It adds the rtstatic=yes option to sip.conf which will not cause the
   SIP realtime (ARA) to not query host=dynamic, because you're telling
   it that all hosts are statically configured.

   You'll only get name=FROMUSER queries.

   You will probably want to leave rtupdate=yes because if it does write
   anything after all, it won't end up in a local DB where nobody could
   see it.

 * Additionally, it makes the queue ringinuse work properly by setting
   the state_interface device to UNKNOWN instead of UNAVAILABLE.

   See also: https://reviewboard.asterisk.org/r/2996/
   See also: vg_uncached-peers-as-queuemembers.patch

diff --git a/channels/chan_sip.c b/channels/chan_sip.c
index 89aa86e..b58c23d 100644
--- a/channels/chan_sip.c
+++ b/channels/chan_sip.c
@@ -736,7 +736,7 @@ static unsigned int default_transports;            /*!< Default Transports (enum
 static unsigned int default_primary_transport;     /*!< Default primary Transport (enum sip_transport) for outbound connections to devices */
 /*@}*/
 
-static struct sip_settings sip_cfg;		/*!< SIP configuration data.
+struct sip_settings sip_cfg;		/*!< SIP configuration data.
 					\note in the future we could have multiple of these (per domain, per device group etc) */
 
 /*!< use this macro when ast_uri_decode is dependent on pedantic checking to be on. */
@@ -5122,6 +5122,9 @@ static void update_peer(struct sip_peer *p, int expire)
 	int rtcachefriends = ast_test_flag(&p->flags[1], SIP_PAGE2_RTCACHEFRIENDS);
 	if (sip_cfg.peer_rtupdate &&
 	    (p->is_realtime || rtcachefriends)) {
+		if (sip_cfg.peer_rtstatic) {
+			ast_log(LOG_WARNING, "Unexpected update_peer for %s when rtstatic=yes\n", p->name);
+		}
 		realtime_update_peer(p->name, &p->addr, p->username, p->fullcontact, p->useragent, expire, p->deprecated_username, p->lastms);
 	}
 }
@@ -5242,7 +5245,8 @@ static const char *get_name_from_variable(const struct ast_variable *var)
 static int realtime_peer_by_name(const char *const *name, struct ast_sockaddr *addr, const char *ipaddr, struct ast_variable **var, struct ast_variable **varregs)
 {
 	/* Peer by name and host=dynamic */
-	if ((*var = ast_load_realtime("sippeers", "name", *name, "host", "dynamic", SENTINEL))) {
+	/* host=dynamic lookup is skipped if we expect only static peers (rtstatic) */
+	if (!sip_cfg.peer_rtstatic && (*var = ast_load_realtime("sippeers", "name", *name, "host", "dynamic", SENTINEL))) {
 		;
 	/* Peer by name and host=IP */
 	} else if (addr && !(*var = ast_load_realtime("sippeers", "name", *name, "host", ipaddr, SENTINEL))) {
@@ -5319,6 +5323,12 @@ static int realtime_peer_by_addr(const char **name, struct ast_sockaddr *addr, c
 	/* We're not finding this peer by this name anymore. Reset it. */
 	*name = NULL;
 
+	/* Don't expect such a lookup for rtstatic. */
+	if (sip_cfg.peer_rtstatic) {
+		ast_log(LOG_WARNING, "Unexpected realtime_peer_by_addr for %s/%s/%s when rtstatic=yes\n",
+				*name, ipaddr, portstring);
+	}
+
 	/* First check for fixed IP hosts with matching callbackextensions, if specified */
 	if (!ast_strlen_zero(callbackexten) && (*var = ast_load_realtime("sippeers", "host", ipaddr, "port", portstring, "callbackextension", callbackexten, SENTINEL))) {
 		;
@@ -5541,6 +5551,7 @@ static struct sip_peer *sip_find_peer_full(const char *peer, struct ast_sockaddr
 		}
 	}
 
+	/* sip_devicestate() calls this with realtime=FALSE and devstate_only=TRUE */
 	if (!p && (realtime || devstate_only)) {
 		/* realtime_peer will return a peer with matching callbackexten if possible, otherwise one matching
 		 * without the callbackexten */
@@ -15806,6 +15817,9 @@ static void destroy_association(struct sip_peer *peer)
 
 	if (!sip_cfg.ignore_regexpire) {
 		if (peer->rt_fromcontact && sip_cfg.peer_rtupdate) {
+			if (sip_cfg.peer_rtstatic) {
+				ast_log(LOG_WARNING, "Unexpected destroy_association for %s when rtstatic=yes\n", peer->name);
+			}
 			ast_update_realtime(tablename, "name", peer->name, "fullcontact", "", "ipaddr", "", "port", "0", "regseconds", "0", "regserver", "", "useragent", "", "lastms", "0", SENTINEL);
 		} else {
 			ast_db_del("SIP/Registry", peer->name);
@@ -18765,7 +18779,7 @@ static void receive_message(struct sip_pvt *p, struct sip_request *req, struct a
 		 * it to the right context.
 		 */
 
-		peer = sip_find_peer(NULL, &p->recv, TRUE, FINDPEERS, 0, p->socket.type);
+		peer = sip_find_peer(NULL, &p->recv, TRUE, FINDPEERS, FALSE, p->socket.type);
 		if (peer) {
 			/* Only if no auth is required. */
 			if (ast_strlen_zero(peer->secret) && ast_strlen_zero(peer->md5secret)) {
@@ -20990,6 +21004,7 @@ static char *sip_show_settings(struct ast_cli_entry *e, int cmd, struct ast_cli_
 		ast_cli(a->fd, "  Realtime Regs:          %s\n", AST_CLI_YESNO(realtimeregs));
 		ast_cli(a->fd, "  Cache Friends:          %s\n", AST_CLI_YESNO(ast_test_flag(&global_flags[1], SIP_PAGE2_RTCACHEFRIENDS)));
 		ast_cli(a->fd, "  Update:                 %s\n", AST_CLI_YESNO(sip_cfg.peer_rtupdate));
+		ast_cli(a->fd, "  Realtime static only:   %s\n", AST_CLI_YESNO(sip_cfg.peer_rtstatic));
 		ast_cli(a->fd, "  Ignore Reg. Expire:     %s\n", AST_CLI_YESNO(sip_cfg.ignore_regexpire));
 		ast_cli(a->fd, "  Save sys. name:         %s\n", AST_CLI_YESNO(sip_cfg.rtsave_sysname));
 		ast_cli(a->fd, "  Auto Clear:             %d (%s)\n", sip_cfg.rtautoclear, ast_test_flag(&global_flags[1], SIP_PAGE2_RTAUTOCLEAR) ? "Enabled" : "Disabled");
@@ -23798,6 +23813,9 @@ static void handle_response_peerpoke(struct sip_pvt *p, int resp, struct sip_req
 			peer->name, s, pingtime, peer->maxms);
 		ast_devstate_changed(AST_DEVICE_UNKNOWN, AST_DEVSTATE_CACHABLE, "SIP/%s", peer->name);
 		if (sip_cfg.peer_rtupdate) {
+			if (sip_cfg.peer_rtstatic) {
+				ast_log(LOG_WARNING, "Unexpected handle_response_peerpoke for %s when rtstatic=yes\n", peer->name);
+			}
 			ast_update_realtime(ast_check_realtime("sipregs") ? "sipregs" : "sippeers", "name", peer->name, "lastms", str_lastms, SENTINEL);
 		}
 		manager_event(EVENT_FLAG_SYSTEM, "PeerStatus",
@@ -27275,7 +27293,7 @@ static int sip_msg_send(const struct ast_msg *msg, const char *to, const char *f
 	}
 
 	if (!ast_strlen_zero(from)) {
-		if ((peer_ptr = sip_find_peer(from, NULL, 0, 1, 0, 0))) {
+		if ((peer_ptr = sip_find_peer(from, NULL, FALSE, FINDUSERS, FALSE, 0))) {
 			ast_string_field_set(pvt, fromname, S_OR(peer_ptr->cid_name, peer_ptr->name));
 			ast_string_field_set(pvt, fromuser, S_OR(peer_ptr->cid_num, peer_ptr->name));
 			sip_unref_peer(peer_ptr, "sip_unref_peer, from sip_msg_send, sip_find_peer");
@@ -29972,6 +29990,7 @@ static int sip_devicestate(const char *data)
 	char *host;
 	char *tmp;
 	struct sip_peer *p;
+	int devstate_only;
 
 	int res = AST_DEVICE_INVALID;
 
@@ -29988,8 +30007,19 @@ static int sip_devicestate(const char *data)
 	 * (presumably to unavailable).  If we ask for a realtime peer here, this would
 	 * load it BACK into memory, thus defeating the point of trying to clear dead
 	 * hosts out of memory.
+	 *
+	 * Thus, we call for realtime=FALSE and devstate_only=TRUE.
+	 * Except when rtstatic=yes.  In that case we will skip the
+	 * realtime lookup altogether because even if we do find it
+	 * in the DB, we'll know two things: (a) that we didn't have
+	 * it in memory already (0 calls) and (b) that it exists
+	 * (NOT_INUSE instead of UNAVAILABLE).
+	 *
+	 * We'll short circuit that and return AST_DEVICE_NOT_INUSE
+	 * at once.
 	 */
-	if ((p = sip_find_peer(host, NULL, FALSE, FINDALLDEVICES, TRUE, 0))) {
+	devstate_only = !sip_cfg.peer_rtstatic;
+	if ((p = sip_find_peer(host, NULL, FALSE, FINDALLDEVICES, devstate_only, 0))) {
 		if (!(ast_sockaddr_isnull(&p->addr) && ast_sockaddr_isnull(&p->defaddr))) {
 			/* we have an address for the peer */
 
@@ -30029,6 +30059,9 @@ static int sip_devicestate(const char *data)
 			res = AST_DEVICE_UNAVAILABLE;
 		}
 		sip_unref_peer(p, "sip_unref_peer, from sip_devicestate, release ref from sip_find_peer");
+	} else if (sip_cfg.peer_rtstatic) {
+		/* Static device and no other data */
+		res = AST_DEVICE_NOT_INUSE;
 	}
 
 	return res;
@@ -31863,6 +31896,7 @@ static int reload_config(enum channelreloadreason reason)
 	ast_set_flag(&global_flags[1], SIP_PAGE2_ALLOWSUBSCRIBE);	/* Default for all devices: TRUE */
 	ast_set_flag(&global_flags[1], SIP_PAGE2_ALLOWOVERLAP_YES);	/* Default for all devices: Yes */
 	sip_cfg.peer_rtupdate = TRUE;
+	sip_cfg.peer_rtstatic = FALSE;
 	global_dynamic_exclude_static = 0;	/* Exclude static peers */
 	sip_cfg.tcp_enabled = FALSE;
 	sip_cfg.websocket_write_timeout = AST_DEFAULT_WEBSOCKET_WRITE_TIMEOUT;
@@ -31989,6 +32023,8 @@ static int reload_config(enum channelreloadreason reason)
 			sip_cfg.rtsave_sysname = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "rtupdate")) {
 			sip_cfg.peer_rtupdate = ast_true(v->value);
+		} else if (!strcasecmp(v->name, "rtstatic")) {
+			sip_cfg.peer_rtstatic = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "ignoreregexpire")) {
 			sip_cfg.ignore_regexpire = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "timert1")) {
@@ -35042,7 +35078,7 @@ static int load_module(void)
 	/* And start the monitor for the first time */
 	restart_monitor();
 
-	if (sip_cfg.peer_rtupdate) {
+	if (sip_cfg.peer_rtupdate && !sip_cfg.peer_rtstatic) {
 		ast_realtime_require_field(ast_check_realtime("sipregs") ? "sipregs" : "sippeers",
 			"name", RQ_CHAR, 10,
 			"ipaddr", RQ_CHAR, INET6_ADDRSTRLEN - 1,
diff --git a/channels/sip/include/sip.h b/channels/sip/include/sip.h
index 87a8c68..75ab6ea 100644
--- a/channels/sip/include/sip.h
+++ b/channels/sip/include/sip.h
@@ -740,6 +740,7 @@ struct __show_chan_arg {
 */
 struct sip_settings {
 	int peer_rtupdate;          /*!< G: Update database with registration data for peer? */
+	int peer_rtstatic;          /*!< G: Only static entries found in DB? */
 	int rtsave_sysname;         /*!< G: Save system name at registration? */
 	int ignore_regexpire;       /*!< G: Ignore expiration of peer  */
 	int rtautoclear;            /*!< Realtime ?? */
@@ -782,6 +783,8 @@ struct sip_settings {
 	int websocket_write_timeout; /*!< Socket write timeout for websocket transports, in ms */
 };
 
+extern struct sip_settings sip_cfg;		/*!< SIP configuration data. A global. */
+
 /*! \brief The SIP socket definition */
 struct sip_socket {
 	enum sip_transport type;  /*!< UDP, TCP or TLS */
diff --git a/channels/sip/security_events.c b/channels/sip/security_events.c
index 24ad8db..e22b23f 100644
--- a/channels/sip/security_events.c
+++ b/channels/sip/security_events.c
@@ -286,6 +286,7 @@ void sip_report_inval_transport(const struct sip_pvt *p, const char *transport)
 int sip_report_security_event(const char *peer, struct ast_sockaddr *addr, const struct sip_pvt *p,
 			      const struct sip_request *req, const int res) {
 
+	int realtime;
 	struct sip_peer *peer_report;
 	enum check_auth_result res_report = res;
 	struct ast_str *buf;
@@ -302,7 +303,8 @@ int sip_report_security_event(const char *peer, struct ast_sockaddr *addr, const
 		[K_LAST]  = { NULL, NULL}
 	};
 
-	peer_report = sip_find_peer(peer, addr, TRUE, FINDPEERS, FALSE, p->socket.type);
+	realtime = sip_cfg.peer_rtstatic ? FALSE : TRUE; /* no extra DB lookups for rtstatic, please */
+	peer_report = sip_find_peer(peer, addr, realtime, FINDPEERS, FALSE, p->socket.type);
 
 	switch(res_report) {
 	case AUTH_DONT_KNOW:
diff --git a/configs/sip.conf.sample b/configs/sip.conf.sample
index c6e6e22..05c8cd3 100644
--- a/configs/sip.conf.sample
+++ b/configs/sip.conf.sample
@@ -1063,6 +1063,9 @@ srvlookup=yes                   ; Enable DNS SRV lookups on outbound calls
                                 ; If not present, defaults to 'yes'. Note: realtime peers will
                                 ; probably not function across reloads in the way that you expect, if
                                 ; you turn this option off.
+;rtstatic=no                    ; SPECIAL HACK: Enable if all your realtime hosts are statically
+                                ; configured. No lookups will be done against host=dynamic and
+                                ; device state lookups will be skipped if not found in memory.
 ;rtautoclear=yes                ; Auto-Expire friends created on the fly on the same schedule
                                 ; as if it had just registered? (yes|no|<seconds>)
                                 ; If set to yes, when the registration expires, the friend will
diff --git a/channels/chan_sip.c b/channels/chan_sip.c
index b58c23d..8b6d508 100644
--- a/channels/chan_sip.c
+++ b/channels/chan_sip.c
@@ -30054,6 +30054,10 @@ static int sip_devicestate(const char *data)
                                res = AST_DEVICE_UNAVAILABLE;
                        else    /* Default reply if we're registered and have no other data */
                                res = AST_DEVICE_NOT_INUSE;
+               } else if (sip_cfg.peer_rtstatic && p->is_realtime) {
+                       /* if this is a (uncached) realtime peer, we don't
+                        * necessarily have an address */
+                       res = AST_DEVICE_UNKNOWN;
                } else {
                        /* there is no address, it's unavailable */
                        res = AST_DEVICE_UNAVAILABLE;
@@ -30061,7 +30065,7 @@ static int sip_devicestate(const char *data)
                sip_unref_peer(p, "sip_unref_peer, from sip_devicestate, release ref from sip_find_peer");
        } else if (sip_cfg.peer_rtstatic) {
                /* Static device and no other data */
-               res = AST_DEVICE_NOT_INUSE;
+               res = AST_DEVICE_UNKNOWN;
        }
 
        return res;
